# HAM 语言零基础入门教程

## 开篇：HAM 语言总览

HAM 是一门极简、高度一致、可移植、可编译的现代编程语言，植根于函数式计算模型，同时天然支持面向对象风格的模块化组装。它的设计追求用最少的核心概念，支持最广泛的工程场景，同时在安全性、表达能力与执行效率之间取得平衡。

---

## 1. 设计思路：从最小内核出发，自然扩展

HAM 的设计遵循最小内核原则：
语言本身只提供一组不可再简化的核心原语，所有更高级的结构与能力，都由这些原语组合而成，而不是通过不断增加语法实现。

HAM 语言层面的**核心结构**只有三类：
- **集合（Set）**：用于描述分类、范围与类型约束；
- **组合（Composition）**：有序键值结构，用于封装、组织数据与逻辑；
- **函数（Function）**：值到值的映射，是计算与抽象的基本单元。

在此之上，HAM 提供：
- **一组通用基础值类型**：整数、浮点数、字符串、布尔等原子值；
- **少量标准内置数据结构**：如列表（List），与基础类型同级别，作为通用构造；
- **求值与生命周期标注**：如 `linear` 标记，用于控制资源使用方式、允许安全的内存优化与独占使用；
- **模块与文件级引用机制**：支持跨文件、跨目录的代码组织，用于构建规模更大的程序。

需要明确区分的是：
**包管理、版本选择、依赖获取等能力，不属于语言语法本身，而是编译器与工具链的职责。**
HAM 语言只定义程序的结构与语义，不把生态工具的逻辑内置到语法中。

---

## 2. 范式定位：函数式为内核，OOP 为组织方式

HAM 的底层计算模型是**函数式**：
- 函数是一等公民
- 支持柯里化、高阶函数、元编程
- 引用透明，无隐含副作用
- 副作用与状态以显式、受控的方式表达
- 与命令式编程模型存在本质区别

这并不与面向对象的思想冲突。
HAM 中：
- 用**组合**实现封装与结构；
- 用**函数**实现行为与方法；
- 用**集合**描述接口与约束；
- 用嵌套与组合实现模块化。

程序员可以**完全使用面向对象的思路来设计、拆分、组装系统**，
但底层运行在更安全、更容易推理的函数式模型之上。

---

## 3. 安全性与良定：语言级别的可预测性

HAM 从设计上支持递归与潜在无限结构，但只允许**数学上良定（well‑defined）**的定义：
- 存在明确的基底或起点
- 依赖关系可确定、可有限展开
- 无不可终止的隐式循环
- 无矛盾、无歧义的语义

这使得：
- 可以安全地表达树、链表、流等结构；
- 编译器可以在更早阶段拒绝不安全的程序；
- 程序行为更可预测、更容易调试。

---

## 4. 执行效率与优化潜力

HAM 的语义模型为高性能执行提供了天然支持：
- **惰性求值**：只在真正需要时计算，避免不必要开销；
- **无副作用与引用透明**：编译器可以安全地重排、缓存、公共子表达式消除；
- **显式资源约束**（如 linear）：允许编译器做更激进的内存优化、原地更新、减少拷贝；
- **内在并发友好**：纯函数片段可以安全地并行执行，无需复杂同步。

这些能力**不是通过库或魔法实现**，而是由语言本身的语义保证，
因此可以在编译器层面稳定、通用地应用，而不依赖程序员手动优化。

---

## 5. 兼容性与可移植性

HAM 的设计从底层就重视广泛部署能力：
- 语法与语义**与平台无关**，不绑定特定操作系统与硬件；
- 编译目标灵活，可以面向不同架构与环境生成执行代码；
- 不内嵌不可移植的系统特性，所有底层交互通过标准接口抽象；
- 模块与引入机制简单稳定，便于跨平台、跨项目复用。

这使得 HAM 可以用于：系统工具、嵌入式逻辑、服务端组件、跨平台库等多种场景，
并在长期演进中保持稳定兼容。

---

## 6. 总结：HAM 的定位

HAM 是一门：
- 以**集合、组合、函数**为核心结构；
- 以**函数式**为计算模型；
- 以**面向对象**为自然组织风格；
- 以**良定、安全、显式**为设计原则；
- 具备高度**可移植性、兼容性、可优化性**；
- 同时支持从小型脚本到大型模块化项目的现代编程语言。

它不追求语法花哨，而是追求**简单、一致、可生长**，
让程序员用最接近自然思考的方式，构建可靠、高效、可维护的系统。
