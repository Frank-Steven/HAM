# 第五章 组合的构造、访问与扩展

## 5.1 组合是 HAM 的一等值
在 HAM 中，所有数据都以组合的形式存在。
组合是若干键值对的集合，所有键必须隶属于某个组合，不能独立存在。
组合可以作为参数、返回值，是语言中最基础的数据单元。

## 5.2 组合的构造
组合必须使用一对大括号 `{ }` 包裹。
内部包含若干键值对，键值对之间使用逗号分隔。
键值对通过赋值语法声明。

组合示例：
```ham
{
    name = "Alice",
    age = 20,
    #tag = "user",
    $lang ← "zh"
}
```
构造规则：
- 以 { 开始，以 } 结束
- 键在前，值在后
- 多个键值对之间用逗号分隔
- 键可以是普通键、私有键 # 或只读键 $
- 支持两种赋值形式：
  - `=` 普通赋值
  - `<-` 支持递归的赋值

## 5.3 键的访问
访问组合中的键，直接使用键名即可。
访问行为遵循第四章的键访问规则：

- 普通键：任意位置可读、可写
- 私有键 `#`：任意位置可读，但外部不建议读取；外部不可写
- 只读键 `$`：任意位置可读，任何位置都不可写

读取不存在的键视为匹配失败，可以通过 `or` 分支处理。

## 5.4 组合的合并
两个组合可以使用竖线符号 | 进行合并。
合并会生成一个新的组合，原有组合保持不变。

合并规则：
- 冲突的键以竖线右侧组合的键为准
- 普通键：正常覆盖
- 私有键 `#`：按普通键规则覆盖，但仅内部可覆盖
- 只读键 `$`：不允许覆盖，试图覆盖视为匹配失败

合并示例：
```ham
{ name = "Alice", age = 20 } | { age = 21, lang = "en" }
```
## 5.5 组合的退化
一个组合即使包含额外的键，只要它完整具备某个集合所要求的全部键，
就可以被视为属于该集合，这一机制称为组合的退化。

退化规则：
- 组合满足集合的全部必填键
- 允许携带额外的键
- 可以被当作该集合的实例安全使用
- 是结构类型与接口复用的基础

## 5.6 组合与封装
私有键 `#` 让组合具备天然封装能力：
- 内部可读写
- 外部可读但不建议使用
- 外部不可写
- 组合对外只暴露稳定的普通键接口

只读键 `$` 用于系统信息、上下文、状态等不可变数据，
保证组合行为可预测、不被篡改。

## 5.7 函数式范式下的面向对象实现
在 HAM 中，基于纯函数式模型即可实现完整的面向对象能力，包含封装、继承与多态，无需传统类与继承语法。

- 使用组合表示对象实例
- 使用私有键 `#` 实现内部状态与实现细节封装
- 使用只读键 `$` 保证不可变约束与安全共享
- 使用组合合并 `|` 实现继承语义
  - 父组合提供基础结构与行为
  - 子组合通过竖线合并扩展、覆盖父组合内容
  - 右侧子组合优先级更高，完成重写
- 使用组合退化实现接口匹配与多态
  - 子组合可退化为父组合类型
  - 满足结构即可兼容使用
- 全程保持不可变、无副作用、无原地修改

该模型完整支持 OOP 三大特性，同时严格遵循函数式设计原则。

## 5.8 本章小结
- 组合是 HAM 唯一的数据结构，一切皆组合
- 组合必须用 `{ }` 包裹，键值对之间用逗号分隔
- 支持 `=` 普通赋值与 `<-` 递归赋值
- 组合使用 `|` 合并，冲突键以右侧为准
- 组合支持退化，满足结构即可视为所属集合
- 组合不可变，合并与扩展均生成新组合
- 私有键与只读键共同实现安全、可靠的封装
- 以纯函数式方式，完整实现面向对象的封装、继承、多态能力
