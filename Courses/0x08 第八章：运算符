# 第八章 运算符

## 8.1 运算符本质
在 HAM 中，所有二元运算符本质上都是**二元函数**的语法糖。
运算符本身是一个**特殊键**，遵循统一的命名与作用域规则。

每个运算符对应一个内部专用名称：
以反引号 ` 开头，后接运算符本身。

例如：
- `+` 对应 `+
- `-` 对应 `-
- `*` 对应 `*
- `/` 对应 `/
- `==` 对应 `==

表达式语法糖形式：
```ham
a + b
```
会被编译器理解为标准前缀函数调用：
```ham
`+(a, b)
```
运算符不是某个对象的成员方法，而是**作用域内的普通二元函数**，与 OOP 风格无关。

## 8.2 关键字型特殊运算符
除符号运算符外，HAM 保留少量小写关键字作为特殊运算符，例如：
or

该运算符用于多值场景下的**贪婪匹配选择**，不是普通逻辑或。
它同样遵循二元函数规则，有对应的内部键，可重载、可作用域限定。

## 8.3 运算符的定义与作用域
在某个组合、模块或作用域内部定义运算符，含义是：
**在当前作用域内，该符号统一使用这个实现。**

- 定义在组合内部 → 只在该组合内部生效
- 不会污染父作用域、外部模块或其他文件
- 不是“给某个类型添加方法”，而是“在这片代码里，符号是什么意思”

二元运算符必须以**接收两个参数**的形式定义，
才能对应 a op b 的语法糖。

## 8.4 运算符的扩展与覆盖
HAM 允许两种方式修改运算符行为：

1. **扩展（推荐）**
   在保留原有语义的基础上，增加新类型支持：
   `+ = `+ or 新二元函数
   利用 or 的贪婪匹配，自动选择最匹配的实现。

2. **直接覆盖（允许，但编译器会警告）**
   直接替换整个运算符的含义：
   `+ = 新二元函数
   原有语义会被丢弃，后续不匹配的类型会自然触发定义域错误。

两种方式都只影响**当前作用域**，不会污染外部。

## 8.5 运算符优先级
HAM 直接采用主流语言通用的运算符优先级，从高到低：
1. 括号
2. 一元运算符
3. 乘法、除法、取模
4. 加法、减法
5. 移位运算
6. 大小比较 < > <= >=
7. 相等性比较 == !=
8. 按位与、异或、或
9. 逻辑运算
10. 关键字运算符（如 or）

## 8.6 纯函数式规则
- 所有运算符都是**纯函数**
- 无副作用，不修改输入值
- 只返回新结果
- 可嵌套、可组合、可作为参数传递
- 无自增、自减、原地修改等可变操作
