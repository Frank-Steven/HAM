# HAM 语言零基础入门教程
## 第一章 基础概念：从最简单的原语开始

本章介绍 HAM 最底层、最稳定的核心概念。整个语言没有特殊语法，没有例外规则，所有结构都遵循同一套计算模型，语法风格直接继承 λ 演算的思想：一切皆表达式，一切皆值。

---

## 1.1 一切都是表达式，一切都是值
在 HAM 中，所有可以被计算、被引用、被组合的东西，统一叫做**值**。

- 数字是值
- 字符串是值
- 布尔值是值
- null 是空值
- 组合是值
- 列表是值
- 函数是值
- 甚至 import 进来的模块也是值

所有语法结构都是**表达式**，表达式的结果就是一个值。
这是最接近 λ 演算的设计：不需要声明、不需要命令、不需要状态，只需要构造值并使用它。

因此，HAM 中一个非常重要的特点是：
任何值都可以直接使用，不必先赋值给名称。

---

## 1.2 基础内置类型
HAM 提供一组最基础、跨平台、与系统无关的原子类型：

- Int：整数
- Float：浮点数
- Bool：布尔值（true / false）
- String：字符串
- Null：空类型，唯一值为 null

这些是所有结构的基础。

---

## 1.3 内置结构：列表 List
List 是 HAM 唯一内置的通用容器结构，与基础类型同级。

### 空列表
不包含任何元素的列表称为空列表：
[]

它是列表的基本形式之一。

### 列表的分类
1. 按长度分
- 定长列表：长度固定
- 不定长列表：支持追加、拼接等操作

2. 按元素类型分
- 单类型列表：所有元素属于同一类型
  例：`[1, 2, 3]` 类型为 `Int[]`
- 多类型列表：元素可以是不同类型
  例：`[1, "abc", true]`

### 多类型列表的类型规则
当列表包含多种类型时，整个列表的类型为：
(元素类型的并集)[]

例如：
```
[1, "test"]
```
元素类型：`Int | String`
列表类型：`(Int | String)[]`

并集类型直接由集合原语支持，不需要额外类型机制。

---

## 1.4 三大核心原语：集合、组合、函数
HAM 整个语言只建立在三个极简原语之上：

### 集合 Set —— 描述“是什么”
集合用于分类、划定范围、表示类型。
它不存储数据，只描述“哪些值属于这一类”。
接口、抽象、类型约束，都由集合表达。

### 组合 Composition —— 描述“怎么放在一起”
组合是有序键值结构，是 HAM 最核心的组织方式。
对象、封装、模块、记录、执行体，都由组合实现。

组合内部的每一项，使用逗号分隔：
```ham
{
  a = 1,
  b = 2,
  c = 3
}
```
### 函数 Function —— 描述“如何变换”
函数是从一个值到另一个值的映射。
所有计算、逻辑、行为都由函数完成。

---

## 1.5 组合与直接成员访问
组合是值，因此可以直接使用，不必先命名。

合法写法：
```ham
{
  a = 1
}.a
```
不需要先赋值给变量，这是 λ 演算风格的直接表达式用法。

成员访问 `.key` 是作用在**值**上的语法，不是作用在名字上。

---

## 1.6 函数与直接调用
函数也是值，可以直接构造、直接调用：
```ham
(x) => { x + 1 }(5)
```
等价于：
```ham
f = (x) => { x + 1 },
f(5)
```
函数调用同样是作用在值上，而非必须绑定名称。

---

## 1.7 名称绑定只是等价替换
在 HAM 中：
```ham
name = value
```
仅仅表示：
之后出现的 name，等价替换为 value。

没有变量、没有状态、没有修改，只有替换。
这让整个语言的行为完全可预测、可推理。

---

## 1.8 模块导入：import 是内置函数
import 不是特殊语法，只是一个内置函数：
```ham
mod = import("utils.ham")
```
它读取文件，返回文件的顶层组合。
导入后的使用方式与普通组合完全一致：
```ham
import("utils.ham").func(...)
```
---

## 1.9 本章小结
HAM 的核心设计可以概括为：

- 一切都是表达式，一切都是值（λ 演算思想）
- 任何值可直接使用，不必先命名
- 三大原语：
  集合（是什么）、组合（怎么放）、函数（怎么变）
- 列表是内置容器，支持空列表 `[]`
- 多类型列表自动使用并集类型，写作 `(A | B)[]`
- 组合内部项用逗号分隔
- 名称 = 等价替换
- 模块 = 组合，import = 函数

语言不添加额外语法，所有高级能力都从最小原语自然涌现。
程序员可以用面向对象的思路组织代码，底层却保持纯函数式的干净与安全。
