# 第13章 编译模型与工程配置（草稿）

## 13.1 本章概览
本章作为 HAM 语言工程化的最终闭环，将明确 HAM 的编译规则、模块组织、入口机制与配置体系。HAM 语言内核不绑定任何第三方包管理器，所有编译行为均由编译命令统一驱动，所有与语言执行相关的配置，均可通过编译命令、文件头元数据与代码注解完成。

## 13.2 HAM 核心工程原则
HAM 坚持极简、透明、可移植的工程设计理念，遵循以下核心原则：
- 编译器是唯一官方工具，无隐式执行逻辑
- 不提供官方包管理器、中央仓库与依赖下载机制
- 包管理、源码获取、版本控制均属于外部生态工具
- 所有影响编译与执行的行为，必须显式可配置
- 一切依赖文件系统与编译命令，不依赖网络与环境变量

## 13.3 编译命令：唯一的官方入口
编译命令是 HAM 唯一的、标准的工程入口。所有与语言运行相关的策略、路径、模式，都必须通过编译命令传递。编译器只处理本地源码，不执行任何网络操作、下载操作与自动依赖安装。

通过编译命令可以指定：
- 入口模块与入口函数
- 模块搜索路径
- 默认并行或线性求值模式
- 全局默认并行度上限
- 全局默认记忆化引用阈值
- 输出目标与优化级别

任何第三方工具或包管理器，最终都必须通过生成标准编译命令来调用 HAM 编译器。

## 13.4 程序入口：由编译命令指定
HAM 不强制规定入口函数必须叫 main，也不限制只能有一个入口。
入口函数完全由编译命令指定，规则非常简单：

- 用户在任意模块中实现一个函数
- 编译时通过参数告诉编译器：哪个模块、哪个函数是入口
- 编译器负责在程序启动时自动调用它
- 一个程序可以定义多种不同入口，用于不同运行模式

入口函数是程序的计算起点，也是整个依赖图的根。
从这里开始，HAM 编译器会自动分析依赖、安排执行顺序、启动求值。

## 13.5 包与包配置的定位
HAM 语言内核不定义包配置格式。
包的结构、配置文件的写法、依赖管理规则，均由使用者或第三方包管理器自行决定。

对 HAM 编译器而言：
- 包只是一个包含多个模块的目录
- 包配置仅作为外部工具的工作文件
- 编译器不解析、不识别非语言标准的配置项

这意味着用户可以自由选择现有的包管理工具，或自行实现简易管理方案，而不会受到语言规范的限制。

## 13.6 三级标准配置体系（语言内核级）
HAM 语言本身只定义三级可被编译器识别的配置，优先级从高到低依次为：

1. 代码内注解
作用于单个函数或绑定，用于细粒度控制并行、线性与记忆化策略。

2. 文件头元数据
位于模块顶部的标准块注释，用于声明当前文件的默认执行策略，编译器可直接解析。

3. 编译命令参数
作为全局默认值，在没有注解与文件头配置时生效，是最基础的兜底配置。

所有配置均只影响执行逻辑，不涉及模块下载与包管理。

## 13.7 模块组织与导入规则
HAM 模块完全基于文件系统组织：
- 一个源码文件对应一个模块
- 导入关系仅表示文件之间的引用
- 编译器依据编译命令指定的搜索路径查找模块
- 不支持基于包名与版本的隐式导入

模块导入保持简单、稳定、可移植，不依赖任何外部生态系统。

## 13.8 与外部包管理器的协作
HAM 不排斥包管理器，但保持完全中立：
- 包管理器负责源码下载、目录组织、依赖管理
- 包管理器生成并调用标准编译命令
- 编译器只负责编译与执行，不感知包管理器的存在
- 不同包管理器、不同工程结构均可兼容

这种设计让 HAM 具备极强的扩展性与生态兼容性。

## 13.9 工程化设计总结
HAM 的工程化体系，以编译器为核心、编译命令为入口、文件系统为基础。语言内核专注于计算模型的安全、高效与优雅，将生态层的包管理、工具链完全开放给社区与用户。

极简、可控、可移植，是 HAM 面向工程与长期未来的核心设计选择。

## 13.10 本章小结
- 编译命令是 HAM 唯一标准官方入口
- 编译命令可指定任意函数作为程序入口，不强制命名为 main
- 支持多入口设计，用于不同运行模式
- 语言内核不提供、不绑定任何官方包管理器
- 包配置与依赖管理由外部工具自由实现
- 编译器只处理本地源码与标准配置
- 三级配置体系：注解 > 文件头元数据 > 编译命令
- 模块基于文件系统，导入规则简单稳定
- 语言内核与生态工具解耦，兼顾简洁与扩展能力
- HAM 工程化体系至此完整闭环
