# 第十章 函子、应用式与单子（完整定稿）

## 10.1 函子、应用式与单子解决了什么问题
在纯函数式计算中，大部分值并不是简单的数值或字符串，而是带有某种上下文的值。比如计算可能成功或失败、结果可能为空、操作可能异步、流程需要顺序依赖执行。如果对每一种上下文都单独设计处理逻辑，会导致代码琐碎、不一致，并且破坏纯函数的透明性与可组合性。

函子、应用式与单子并不是某一门语言的特殊语法，而是函数式理论中通用的计算抽象结构。它们的目的，是为各种带上下文的计算提供一套统一、安全、可复用的组合方式，让复杂的程序流程依然保持纯函数特性、无副作用、可推理、可组合。

## 10.2 直观类比：状态空间与指针
我们可以将程序中所有可能的状态与值，看作一个巨大的**状态空间集合**，普通的值就是这个空间中的一个点、一个元素。

而函子、应用式、单子，可以理解为这个状态空间中的**地址、迭代器、坐标**，它们不直接是值本身，而是指向值的位置、可以一步步到达目标的计算规则，以及在状态空间中合法移动的规范。

## 10.3 三者的统一模型：不可变状态与指针移动
在纯函数式计算模型中，所有状态与值都是不可变的。既然不可变，就不存在“修改内部值”的行为，程序运行的本质只有一件事：

**从当前状态，移动到下一个状态。**

我们可以把程序中所有可能出现的状态，看作一个巨大的状态空间。
- 一个普通的值，是这个状态空间里的一个点。
- 函子、应用式、单子，则可以理解为状态空间上的抽象指针、坐标或迭代器。

这里存在一个核心关系：
**状态空间中的每一个值，与指针空间中的每一个指针，一一对应，互为双射。**

一个值唯一对应一个指针，一个指针也唯一指向一个值，没有歧义、没有重叠、没有遗漏。

函子、应用式、单子本质上是同一个模型，并非三种完全不同的事物。它们只是对“状态如何安全移动”这一行为，抽象出的三套不同规则、三套可控 API。

这套统一模型的核心是：
1. 状态不可变，只能从一个状态移动到另一个状态。
2. 没有修改，只有移动。
3. 函子、应用式、单子只是把这种状态移动规范化、抽象化、安全化，使用者无需手动判断、手动跳转，就能在状态空间里安全、可控、可组合地移动。

三者的区别仅在于：允许使用什么样的函数与指针，来决定这一步该如何移动。

## 10.4 三种统一的指针移动规则
下面三种规则，全部基于同一个指针模型，只是传入的指针与函数类型不同，从而实现不同的移动能力。

### 10.4.1 函子（Functor）—— 最基础的移动
- 持有：**一个值指针**
- 传入：**普通函数（值 → 值）**
- 行为：用函数计算出下一个值，再生成对应的新值指针
- 特点：不改变指针结构，只在同一种指针内部移动
- 理解：从一个坐标，按函数计算，跳到下一个坐标

### 10.4.2 应用式（Applicative）—— 函数也在指针里的移动
- 持有：**一个值指针**
- 传入：**一个函数指针**（指针内部包裹了「值 → 值」函数）
- 行为：把函数指针里的函数，应用到值指针里的值，得到新值指针
- 特点：两个指针独立计算，最后合并成一个结果指针
- 理解：用“坐标里的规则”去运算“坐标里的值”

### 10.4.3 单子（Monad）—— 动态生成下一个指针
- 持有：**一个值指针**
- 传入：**一个函数：值 → 新指针**，这个函数接收一个普通值，直接返回一个新指针（新坐标）
- 行为：
  1. 从当前值指针中拿到对应的值
  2. 把这个值传给你传入的函数
  3. 函数直接计算并返回下一个新指针
- 特点：不是固定变换值，而是动态决定下一个指针位置；后一个位置，依赖前一个指针指向的值；一旦指针指向无效状态，后续移动自动停止（短路）
- 理解：根据当前所在坐标，动态计算下一个坐标，而不是只改坐标里的值。

## 10.5 三者的共同点与核心差异（总结）
共同点：
- 都基于不可变状态，只有移动，没有修改
- 都是状态空间上的指针
- 都实现了安全、可控的状态跳转

核心差异：
- **函子：** 值指针 + 普通函数，计算新值得到新指针
- **应用式：** 值指针 + 函数指针，组合两个指针得到新指针
- **单子：** 值指针 + 能返回新指针的函数，直接计算下一个指针

它们是同一套模型下，能力逐级增强的三种 API。

## 10.6 与经典函数式术语的对应（装箱、拆箱）
为了与通用函数式编程标准术语对齐，这里把我们的指针/状态空间模型，和传统说法做一一对应：

- **装箱（wrap）**
  对应：从值到指针 → **取地址**
  把一个普通值，包装成指针空间里的指针。

- **拆箱（unwrap）**
  对应：从指针到值 → **解引用**
  通过指针，拿到它指向的状态空间里的值。

经典说法里的 map、ap、flatMap 操作，在我们的模型中本质完全一致，没有魔法、没有嵌套、没有破坏不可变性，全程只是值与指针的安全移动与对应。

## 10.7 本模型相较于传统解释的优越性
传统函数式教学中，大量使用「装箱、拆箱、嵌套、铺平」等概念，虽然符合标准术语，但容易让人陷入层层包裹的复杂结构中，理解成本高，且容易迷失本质。

而我们这套状态空间 + 指针的统一模型，具有明显的优越性：

1. **没有多层装箱与拆箱的嵌套**
全程不存在多层包裹、层层解包的结构，所有抽象结构都只是指针。

2. **思维极度清晰：指针匹配指针，值匹配值**
你只需要遵循最简单的规则：操作值就用普通函数，操作指针就用指针规则；函数在指针里，就按指针处理；函数返回新指针，也按指针处理。

3. **与传统语言的多级指针思维完全一致**
这套模型的思考方式，和其他编程语言里多级指针、地址、引用的用法是同构的。有过基础开发经验的人，可以零成本、直觉式理解函子、应用式、单子，不需要重新适应一套全新的抽象隐喻。

4. **牢牢抓住本质：只有移动，没有修改**
一切都回归到不可变状态 + 状态空间移动，不被语法、包装、嵌套干扰，直击计算模型的核心。

简单说：传统解释让你关注箱子怎么套箱子；我们的解释让你只关注指针怎么移动。

## 10.8 常见实践：核心方法与真实应用
### 10.8.1 核心方法与三种指针移动的对应
在实际函数式编程中，以下标准方法直接对应我们的指针模型操作：

- **of**
作用：把一个普通值，变成对应的指针
对应模型：**给值取地址，生成指针**，是所有指针的起点。

- **unwrap / extract**
作用：从指针中，拿到它指向的值
对应模型：**指针解引用**，是指针的反向操作。

- **map**
对应：**函子的移动规则**
传入：普通函数（值 → 值）
行为：计算新值 → 得到新指针

- **ap**
对应：**应用式的移动规则**
传入：函数指针
行为：函数指针 + 值指针 → 新值指针

- **flatMap / bind**
对应：**单子的移动规则**
传入：函数（值 → 新指针）
行为：用当前值，直接算出下一个指针

### 10.8.2 最常见的实际单子实例
单子是三者中能力最强的，也是工程实践中应用最广泛的抽象，常见实例包括：

- **Option / Maybe**
表示可能为空的指针，通过 map / flatMap 实现自动判空、避免空指针异常。

- **Result / Either**
表示可能成功或失败的指针，通过 flatMap 实现出错自动短路，无需手动判断异常。

- **IO**
表示带有输入输出副作用的指针，本身不立刻执行操作，仅指向“待执行的动作”，是纯函数式语言中管理副作用的核心方案。

- **Promise / 异步任务**
表示未来才会得到的值的指针，then / flatMap 本质就是等待当前指针就绪后，再动态跳转到下一个指针。

### 10.8.3 实践小结
- `of` = 造指针（取地址）
- `unwrap` = 取值（解引用）
- `map` = 函子移动
- `ap` = 应用式移动
- `flatMap` = 单子移动

无论是空值安全、错误处理、副作用管理，还是异步流程控制，全都不需要新增语法，本质上都只是指针在状态空间里的不同移动方式。

## 10.9 对比：使用 HAM 指针 API 与不使用的差异
以“可能为空的值 + 连续计算”为例，用原生 HAM 语法直观对比。

### 不使用函子 / 单子（原生手动写法）
```ham
{
  a = getValue(),
  b = if(a != null) computeB(a),
  c = if(b != null) computeC(b),
  result = if(c != null) c
}
```
问题：
- 必须一层层手动判空
- 每个 if 都要绑定键，冗余繁琐
- 依赖关系隐式，容易写错顺序
- 业务逻辑被安全判断淹没
- 层级越深，维护越难

### 使用 HAM 统一指针 API（函子 + 单子）
```ham
{
  result =
    getValue()
      .map(a => computeB(a))
      .flatMap(b => computeC(b))
}
```
优势：
- 无多余键、无手动 if
- 空值自动短路，安全由模型保证
- 只写业务逻辑，不写模板代码
- 线性流畅，意图清晰
- 完全贴合「状态空间 + 指针移动」模型
- 可维护性、严密性、整洁度大幅提升

## 10.10 本章最终总结
1. 计算的本质不是修改，而是**在不可变状态空间中移动指针**。
2. 函子、应用式、单子不是三种不同结构，而是**同一套指针模型的三种移动规则**。
3. 核心 API 与指针模型一一对应：
   - `of`      = 生成指针（取地址）
   - `unwrap`  = 解引用取值
   - `map`     = 函子移动
   - `ap`      = 应用式移动
   - `flatMap` = 单子移动
4. 本模型抛弃多层装箱嵌套，只遵循**指针匹配指针、值匹配值**，更底层、更直观、更接近系统级思维。
5. 工程上可**消除嵌套、消灭重复判断、提升代码严密性与可维护性**。
6. 这是一套**既回归本质、又符合标准、还极简好用**的函数式编程模型。
