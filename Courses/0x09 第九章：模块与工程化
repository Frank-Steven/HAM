# 第九章 模块与工程化（正式版）
## 9.1 模块本质
在 HAM 中，一个源码文件即为一个模块。模块的本质是文件级别的顶级组合，文件内所有顶层定义，都是该组合的键值对。模块之间的隔离、复用与交互，全部基于已有的组合、作用域与函数机制，不新增独立的模块语法体系。

## 9.2 模块元数据与导出声明
每个模块必须在文件最顶部，使用双星星高级块注释，统一声明模块元数据与导出列表。

```ham
/**
 * @module Math
 * @description 基础数学运算模块
 * @version 1.0.0
 * @exports add, multiply, square
 */
```
其中：
@module 用于定义模块名称
@description 为模块功能说明
@version 为版本信息
@exports 以逗号分隔列出对外暴露的顶层键

所有未写入 @exports 列表的顶层键，默认为模块私有，仅当前文件内部可用。

## 9.3 模块导入：内置 import 函数
HAM 不设计独立的导入语法，所有模块导入均通过内置 import 函数完成。import 是标准纯函数，可接收文件路径或包配置中定义的模块名称，返回目标模块的公开组合。

导入整个模块：
```ham
Math = import("./Math.ham")
```
选择性解构导入：
```ham
{ add, multiply } = import("./Math.ham")
```
import 也支持传入包配置里定义的模块名，方便统一管理依赖。

## 9.4 导入时的键重命名
如果需要将其他模块的键导入并改名，直接使用组合访问加赋值即可，不新增任何语法。

单行改名导入：
```ham
add = import("./Math.ham").add
```
多键改名
```ham
Math = import("./Math.ham")
add = Math.add
mul = Math.multiply
sq = Math.square
```
改名后的键属于当前模块所有，与原模块无关。

## 9.5 导入的核心语义：拷贝、隔离、无副作用
导入操作的本质，是将目标模块公开的键拷贝一份到当前模块，成为当前模块自己的键。

- 导入后的键只在当前模块作用域内生效
- 对其进行修改、重载、扩展，不会影响原模块
- 也不会影响其他任何使用该模块的地方
- 不存在共享、引用、全局污染等潜在风险

这是 HAM 模块系统安全、可预测的核心保证。

## 9.6 语法解析说明
等号左侧的 `{ add, multiply }` 是解构模式，用于从组合中提取键。
等号右侧的 `{ ... }` 是组合字面量。
两者位置不同，语义明确，解析器可清晰区分，无歧义。

## 9.7 可见性与作用域规则
模块顶层键默认私有，仅当前文件可见。只有 @exports 中声明的键会被加入公开组合。外部访问私有键会触发定义域不匹配错误。
导入的键同样受当前模块作用域管理，不会泄漏到外部。

## 9.8 编译、入口与包配置
程序入口不由代码内部决定，而是由编译命令或包配置文件指定。

编译器从入口模块开始：
- 递归解析所有 import 依赖
- 收集所有模块的公开组合与作用域
- 执行类型检查与优化
- 生成最终可执行程序

包配置文件用于：
- 声明项目信息
- 指定程序入口
- 定义模块名称与路径映射
- 管理依赖与编译选项

import 中传入的名称，会由编译器根据包配置自动解析为真实路径。

## 9.9 模块与组合的统一模型
文件 = 模块
模块 = 顶级组合
导出 = 公开组合中的部分键
导入 = 复制另一组合的公开键到当前作用域

整个模块系统完全建立在组合与作用域之上，内核统一、极简、安全、可推理。
