# 第12章 依赖分析、执行顺序与自适应记忆化（草稿）

## 12.1 本章概览
上一章我们介绍了惰性求值与并行/线性求值策略。
本章将深入编译器的核心行为：**依赖分析、执行顺序**，以及 HAM 中关键的执行优化机制——**自适应记忆化**。
它会根据计算的引用热度，自动决定是否缓存结果，在执行效率与内存占用之间取得平衡。
所有策略与参数均支持多级别配置，兼顾灵活性与安全性。

## 12.2 依赖分析与执行顺序
在 HAM 中，用户只声明表达式之间的关系，不指定执行顺序。
编译器通过**依赖分析**，自动构建程序的**依赖图**：

- 如果一个表达式使用了另一个表达式的值，则形成依赖关系
- 有依赖的表达式，必须等待被依赖项计算完成
- 无依赖的表达式，可以乱序执行或并行执行
- 递归定义（←）会被识别为递归依赖，按惰性展开规则处理

依赖只与**数据引用**有关，与代码书写顺序无关。

## 12.3 共享结果与记忆化
在纯函数式模型中，**同一个函数、相同参数，必然得到相同结果**。
为了避免重复计算，HAM 会对满足条件的结果进行缓存与复用。
对算法开发者而言，这种机制就是**记忆化（Memoization）**。

记忆化带来的好处：
- 避免重复计算，提升执行效率
- 并行访问时天然安全，无需锁与同步
- 递归结构、无限结构可以高效展开

## 12.4 自适应记忆化：按引用热度决定缓存
HAM 不使用全局一刀切的记忆化，而是采用**自适应策略**：

- 一个（函数 + 参数）的**引用次数达到设定阈值**时，才会被记忆化
- 引用次数低、一次性使用的计算，**不记忆化**，计算完成后直接释放
- 记忆化的结果通过**引用计数**管理生命周期，无引用时自动释放

这样既保证了热点计算的速度，又避免了冷点计算浪费内存。

## 12.5 并行度与内存保护
记忆化与并行计算面临同样的资源瓶颈：无节制展开会导致内存占用过高。
HAM 使用**并行度上限**从源头控制资源：

- 同一时间最多只允许固定数量的计算并行执行
- 限制了同时存活的中间结果数量
- 避免瞬间展开大量结构导致内存暴涨

并行度既是 CPU 调度策略，也是内存安全闸门。

## 12.6 多级配置方式
记忆化阈值、并行策略、执行模式，全部支持四级配置，优先级从高到低：

1. 代码内注解（细粒度）
   - @parallel / @linear
   - 可附加记忆化开关、阈值
2. 文件头块注释元数据（模块级）
```ham
/**
 * @parallel
 * @memo_threshold 3
 */
 ```
3. 包配置文件（包级）
   - 设置整个包的默认并行度、记忆化阈值
4. 编译命令（全局）
```
   - ham build --parallel=4
   - ham build --memo-threshold=2
```
用户可以根据场景自由平衡性能、内存与并发。

## 12.7 记忆化的设计取舍
自适应记忆化是 HAM 在效率与资源之间的平衡设计：

- 引用多、高频使用 → 缓存，提升速度
- 引用少、临时使用 → 不缓存，节省内存
- 引用计数管理生命周期，不会只增不减
- 并行度上限防止极端场景下的内存膨胀

## 12.8 本章小结
- HAM 通过**依赖分析**自动确定执行顺序，用户只需声明逻辑
- 无依赖可并行，有依赖必须按序执行
- 内置**自适应记忆化**：按引用次数阈值决定是否缓存结果
- 记忆化结果由**引用计数**管理，无引用则释放
- **并行度上限**同时保护 CPU 与内存安全
- 所有策略支持：注解、文件元数据、包配置、编译命令四级控制
- 纯函数、不可变、惰性、记忆化、并行，共同构成高效安全的执行模型
